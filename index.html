<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D City Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; user-select: none; }
        
        #settings-icon {
            position: absolute; top: 20px; left: 20px; font-size: 2rem;
            cursor: pointer; z-index: 20; color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            transition: transform 0.2s;
        }
        #settings-icon:hover { transform: rotate(45deg); }
        
        #settings-panel {
            position: absolute; top: 70px; left: 20px;
            background: rgba(0,0,0,0.7); color: white;
            padding: 15px 25px; border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            z-index: 20; display: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
        }
        #settings-panel h3 { margin: 0 0 10px 0; font-size: 1.2rem; border-bottom: 1px solid #555; padding-bottom: 5px; }
        .radio-group { display: flex; flex-direction: column; gap: 5px; margin-bottom: 15px; }
        .radio-group label { cursor: pointer; }
        .controls p { margin: 5px 0; font-size: 0.85rem; color: #ccc; }
        .highlight { color: #ffcc55; font-weight: bold; }

        #item-panel {
            position: absolute; top: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 8px; z-index: 20;
        }
        .item {
            background: rgba(0,0,0,0.6); color: white;
            padding: 10px 15px; border-radius: 5px;
            border: 2px solid transparent; cursor: pointer;
            font-weight: bold; font-size: 1rem;
            transition: all 0.2s; display: flex; align-items: center; gap: 8px;
        }
        .item:hover { background: rgba(50,50,50,0.8); }
        .item.active { 
            background: rgba(0, 120, 255, 0.7); 
            border-color: #fff; transform: scale(1.05); 
            box-shadow: 0 0 15px rgba(0,150,255,0.5);
        }
        .item-key {
            background: rgba(255,255,255,0.2); padding: 2px 6px;
            border-radius: 3px; font-size: 0.8rem;
        }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 6px; height: 6px; background: rgba(255,255,255,0.9);
            border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; z-index: 5;
            box-shadow: 0 0 4px rgba(0,0,0,1);
        }
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white;
            cursor: pointer; z-index: 10;
        }
        #blocker h1 { font-size: 2.5rem; margin-bottom: 10px; }
        #blocker p { font-size: 1.2rem; }

        #heli-panel {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(0, 50, 0, 0.8); color: #0f0;
            padding: 15px; border-radius: 8px;
            border: 2px solid #0f0;
            z-index: 20; display: none;
            font-family: monospace; font-size: 1rem;
            box-shadow: 0 0 10px #0f0;
            text-shadow: 0 0 5px #0f0;
            pointer-events: none;
        }
        #heli-panel h3 { margin: 0 0 10px 0; border-bottom: 1px solid #0f0; padding-bottom: 5px; }
        .heli-instructions { margin-top: 15px; font-size: 0.85rem; color: #afa; line-height: 1.4; }
    </style>
</head>
<body>
    <div id="settings-icon" title="è¨­å®šã‚’é–‹ã">âš™ï¸</div>
    <div id="settings-panel">
        <h3>æ™‚é–“å¸¯è¨­å®š</h3>
        <div class="radio-group">
            <label><input type="radio" name="timeMode" value="auto" checked> ğŸ”„ AUTO (è‡ªå‹•é€²è¡Œ)</label>
            <label><input type="radio" name="timeMode" value="morning"> ğŸŒ… æœ</label>
            <label><input type="radio" name="timeMode" value="noon"> â˜€ï¸ æ˜¼</label>
            <label><input type="radio" name="timeMode" value="evening"> ğŸŒ‡ å¤•æ–¹</label>
            <label><input type="radio" name="timeMode" value="night"> ğŸŒŒ å¤œ</label>
        </div>
        <h3>æ“ä½œæ–¹æ³•</h3>
        <div class="controls">
            <p>ã€WASDã€‘ç§»å‹• / ã€ãƒã‚¦ã‚¹ã€‘è¦–ç‚¹</p>
            <p>ã€Spaceã€‘ã‚¸ãƒ£ãƒ³ãƒ—</p>
            <p>ã€Shiftã€‘ãƒ€ãƒƒã‚·ãƒ¥ (ğŸªæ»‘ç©º)</p>
            <p class="highlight">ã€å·¦ã‚¯ãƒªãƒƒã‚¯ã€‘ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨ (ğŸšå¬å–š)</p>
            <p>ã€1ã€œ4ã‚­ãƒ¼ã€‘ã‚¢ã‚¤ãƒ†ãƒ åˆ‡ã‚Šæ›¿ãˆ</p>
            <p>ã€Fã€‘ãƒ˜ãƒªã«ä¹—ã‚Šè¾¼ã‚€/é™ã‚Šã‚‹</p>
        </div>
    </div>

    <div id="item-panel">
        <div class="item active" data-id="laser"><span class="item-key">1</span> ğŸ”— ãƒ¬ãƒ¼ã‚¶ãƒ¼</div>
        <div class="item" data-id="gun"><span class="item-key">2</span> ğŸ”« éŠƒ</div>
        <div class="item" data-id="glider"><span class="item-key">3</span> ğŸª ã‚°ãƒ©ã‚¤ãƒ€ãƒ¼</div>
        <div class="item" data-id="heli"><span class="item-key">4</span> ğŸš ãƒ˜ãƒªã‚³ãƒ—ã‚¿ãƒ¼</div>
    </div>

    <div id="blocker">
        <h1>ãƒ¡ã‚¬ã‚·ãƒ†ã‚£ãƒ»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>
        <p>ç”»é¢ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚²ãƒ¼ãƒ ã«æˆ»ã‚‹ (ESCã‚­ãƒ¼ã§ãƒ¡ãƒ‹ãƒ¥ãƒ¼æ“ä½œ)</p>
    </div>

    <div id="heli-panel">
        <h3>HELI CONTROL</h3>
        <div class="heli-instructions">
            ã€W/Sã€‘å‰é€² / å¾Œé€€ (Pitch)<br>
            ã€A/Dã€‘å·¦å³ç§»å‹• (Roll)<br>
            ã€Q/Eã€‘æ—‹å› (Yaw)<br>
            ã€Spaceã€‘ã‚¹ãƒ­ãƒƒãƒˆãƒ«UP (ä¸Šæ˜‡)<br>
            ã€Shiftã€‘ã‚¹ãƒ­ãƒƒãƒˆãƒ«DOWN (ä¸‹é™)<br>
            ã€Hã€‘ãƒ›ãƒãƒªãƒ³ã‚° ON/OFF<br>
            ã€Fã€‘ãƒ˜ãƒªã‚’é™ã‚Šã‚‹
        </div>
    </div>

    <div id="crosshair"></div>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        // --- UI & è¨­å®šãƒ­ã‚¸ãƒƒã‚¯ ---
        const settingsIcon = document.getElementById('settings-icon');
        const settingsPanel = document.getElementById('settings-panel');
        const blocker = document.getElementById('blocker');
        
        settingsIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
        });
        settingsPanel.addEventListener('mousedown', e => e.stopPropagation());
        settingsIcon.addEventListener('mousedown', e => e.stopPropagation());

        let fixedTime = -1; // -1: Auto
        document.querySelectorAll('input[name="timeMode"]').forEach(el => {
            el.addEventListener('change', (e) => {
                const v = e.target.value;
                if (v === 'auto') fixedTime = -1;
                else if (v === 'morning') fixedTime = 0.23;
                else if (v === 'noon') fixedTime = 0.4;
                else if (v === 'evening') fixedTime = 0.75;
                else if (v === 'night') fixedTime = 0.0;
            });
        });

        let currentItem = 'laser';
        const items = document.querySelectorAll('.item');
        const setItem = (id) => {
            items.forEach(i => i.classList.remove('active'));
            const target = Array.from(items).find(i => i.dataset.id === id);
            if (target) {
                target.classList.add('active');
                currentItem = id;
            }
        };
        items.forEach(item => {
            item.addEventListener('click', (e) => { e.stopPropagation(); setItem(item.dataset.id); });
        });
        document.addEventListener('keydown', e => {
            if (e.key === '1') setItem('laser');
            if (e.key === '2') setItem('gun');
            if (e.key === '3') setItem('glider');
            if (e.key === '4') setItem('heli');
        });

        // --- åŸºæœ¬ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x87ceeb, 0.0012);

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(-20, 5, 20); // å°‘ã—ä¸­å¿ƒã‹ã‚‰ãšã‚‰ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffeedd, 1.2);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048;
        const d = 350;
        sunLight.shadow.camera.left = -d; sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d; sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.far = 1000;
        scene.add(sunLight);

        // æ˜Ÿç©º
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 4000;
        const posArray = new Float32Array(starsCount * 3);
        for(let i = 0; i < starsCount * 3; i+=3) {
            posArray[i] = (Math.random() - 0.5) * 3000;
            posArray[i+1] = Math.random() * 1000 + 100;
            posArray[i+2] = (Math.random() - 0.5) * 3000;
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starsMat = new THREE.PointsMaterial({color: 0xffffff, size: 1.5, transparent: true, opacity: 0});
        const starField = new THREE.Points(starsGeo, starsMat);
        scene.add(starField);

        // --- ãƒãƒ†ãƒªã‚¢ãƒ«ç”Ÿæˆ ---
        const bldMaterials = []; const bldEmissiveMats = []; const aviationLights = [];
        const cRoof = document.createElement('canvas'); cRoof.width = 128; cRoof.height = 128;
        const ctxRoof = cRoof.getContext('2d');
        ctxRoof.fillStyle = '#666'; ctxRoof.fillRect(0,0,128,128);
        ctxRoof.fillStyle = '#555'; for(let i=0; i<300; i++) ctxRoof.fillRect(Math.random()*128, Math.random()*128, 4, 4);
        const roofMat = new THREE.MeshStandardMaterial({map: new THREE.CanvasTexture(cRoof), roughness: 0.9});

        const cRoad = document.createElement('canvas'); cRoad.width = 256; cRoad.height = 256;
        const ctxRoad = cRoad.getContext('2d');
        ctxRoad.fillStyle = '#333'; ctxRoad.fillRect(0,0,256,256);
        ctxRoad.fillStyle = '#fff'; for(let i=0; i<256; i+=32) ctxRoad.fillRect(i, 126, 16, 4);
        ctxRoad.fillRect(0, 10, 256, 4); ctxRoad.fillRect(0, 242, 256, 4);
        const roadMat = new THREE.MeshStandardMaterial({map: new THREE.CanvasTexture(cRoad), roughness: 0.9});

        const bldTypes = [
            { c: '#555', w: '#222', ew: '#ffddaa', s: 'grid' },
            { c: '#7a4e3b', w: '#111', ew: '#ffcc88', s: 'vert' },
            { c: '#445566', w: '#111', ew: '#eebbff', s: 'tall' },
            { c: '#2a4d69', w: '#112233', ew: '#aaccff', s: 'glass'},
            { c: '#888', w: '#333', ew: '#ffffff', s: 'horiz' }
        ];

        bldTypes.forEach(t => {
            const c1 = document.createElement('canvas'); c1.width = 256; c1.height = 256;
            const ctx1 = c1.getContext('2d');
            const c2 = document.createElement('canvas'); c2.width = 256; c2.height = 256;
            const ctx2 = c2.getContext('2d');

            ctx1.fillStyle = t.c; ctx1.fillRect(0,0,256,256);
            ctx2.fillStyle = '#000'; ctx2.fillRect(0,0,256,256);

            const drawWin = (x, y, w, h) => {
                ctx1.fillStyle = t.w; ctx1.fillRect(x, y, w, h);
                if (Math.random() > 0.2) { ctx2.fillStyle = t.ew; ctx2.fillRect(x, y, w, h); }
            };

            if (t.s === 'grid') { for(let y=10; y<256; y+=30) for(let x=10; x<256; x+=30) drawWin(x, y, 20, 20); }
            else if (t.s === 'vert') { for(let y=15; y<256; y+=35) for(let x=15; x<256; x+=35) drawWin(x, y, 15, 20); }
            else if (t.s === 'tall') { for(let y=5; y<256; y+=40) for(let x=10; x<256; x+=25) drawWin(x, y, 15, 30); }
            else if (t.s === 'glass') {
                ctx1.strokeStyle = '#557799'; ctx1.lineWidth = 2;
                for(let y=0; y<256; y+=20) { ctx1.beginPath(); ctx1.moveTo(0,y); ctx1.lineTo(256,y); ctx1.stroke(); }
                for(let x=0; x<256; x+=20) { ctx1.beginPath(); ctx1.moveTo(x,0); ctx1.lineTo(x,256); ctx1.stroke(); }
                for(let y=5; y<256; y+=20) for(let x=5; x<256; x+=20) drawWin(x, y, 10, 10);
            } else if (t.s === 'horiz') {
                for(let y=10; y<256; y+=40) for(let x=0; x<256; x+=40) drawWin(x, y, 35, 15);
            }

            const tex1 = new THREE.CanvasTexture(c1); tex1.wrapS = tex1.wrapT = THREE.RepeatWrapping;
            const tex2 = new THREE.CanvasTexture(c2); tex2.wrapS = tex2.wrapT = THREE.RepeatWrapping;

            const isGlass = t.s === 'glass';
            const sideMat = new THREE.MeshStandardMaterial({
                map: tex1, emissiveMap: tex2, emissive: 0xffffff, emissiveIntensity: 0,
                roughness: isGlass ? 0.2 : 0.7, metalness: isGlass ? 0.8 : 0.2
            });
            bldEmissiveMats.push(sideMat);
            bldMaterials.push([sideMat, sideMat, roofMat, roofMat, sideMat, sideMat]);
        });

        const walkableObjects = [];
        const streetLightPositions = [];
        const lightBulbs = [];

        // --- åœ°å½¢ã¨å·ã®ç”Ÿæˆ ---
        const blockSize = 34; 
        const roadWidth = 14; 
        const gridSize = 36;
        const citySize = gridSize * blockSize;

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(citySize, citySize), new THREE.MeshStandardMaterial({color: 0x222222}));
        ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true;
        scene.add(ground); walkableObjects.push(ground);

        const riverMat = new THREE.MeshBasicMaterial({color: 0x336688, transparent: true, opacity: 0.85});
        const riverBedMat = new THREE.MeshStandardMaterial({color: 0x111111});
        const concreteMat = new THREE.MeshStandardMaterial({color: 0x888888, roughness: 0.8});

        function addRoofDetails(group, h, s) {
            // ã‚¢ãƒ³ãƒ†ãƒŠç­‰ã®è£…é£¾
            if (Math.random() > 0.4) {
                const antH = 8 + Math.random() * 6;
                const ant = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, antH, 8), new THREE.MeshStandardMaterial({color: 0x999}));
                ant.position.set((Math.random()-0.5)*(s-2), h + antH/2, (Math.random()-0.5)*(s-2));
                group.add(ant);
            }

            // å±‹ä¸Šã®4éš…ã«èˆªç©ºéšœå®³ç¯ã‚’è¿½åŠ  (é«˜ã•40ä»¥ä¸Š)
            if (h > 40) {
                const hs = s / 2 - 0.5; // å°‘ã—å†…å´
                const avGeo = new THREE.SphereGeometry(0.4, 8, 8);
                const avMat = new THREE.MeshBasicMaterial({color: 0x220000});
                aviationLights.push(avMat);
                [[-hs, -hs], [hs, -hs], [-hs, hs], [hs, hs]].forEach(([ox, oz]) => {
                    const av = new THREE.Mesh(avGeo, avMat);
                    av.position.set(ox, h + 0.4, oz);
                    group.add(av);
                });
            }
        }

        // --- è¡—ãƒ»ç‰¹æ®Šå»ºç‰©ã®ç”Ÿæˆ ---
        for(let x = -gridSize/2; x < gridSize/2; x++) {
            for(let z = -gridSize/2; z < gridSize/2; z++) {
                const px = x * blockSize, pz = z * blockSize;

                // --- é«˜æ¶é‰„é“ã¨é§… (x = 0 ã®ãƒ©ã‚¤ãƒ³) ---
                if (x === 0) {
                    
                    const isStation = (z === 0);
                    
                    // é«˜æ¶ã®æ”¯æŸ±
                    const pillar = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 12), concreteMat);
                    pillar.position.set(px, 6, pz); scene.add(pillar);
                    
                    // é«˜æ¶ã®åºŠ
                    const deckWidth = isStation ? 26 : 10;
                    const deck = new THREE.Mesh(new THREE.BoxGeometry(deckWidth, 1, blockSize + 1), concreteMat);
                    deck.position.set(px, 12.5, pz); scene.add(deck); walkableObjects.push(deck);

                    // ç·šè·¯
                    const railMat = new THREE.MeshStandardMaterial({color: 0x333333});
                    const rail1 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.5, blockSize + 1), railMat);
                    rail1.position.set(px - 2, 13, pz); scene.add(rail1);
                    const rail2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.5, blockSize + 10), railMat);
                    rail2.position.set(px + 2, 13, pz); scene.add(rail2);

                    if (isStation) {
                        // ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 
                        const platMat = new THREE.MeshStandardMaterial({color: 0xaaaaaa});
                        const platform1 = new THREE.Mesh(new THREE.BoxGeometry(6, 1.5, blockSize), platMat);
                        platform1.position.set(px - 7, 13.5, 50); scene.add(platform1); walkableObjects.push(platform1);
                        
                        const platform2 = new THREE.Mesh(new THREE.BoxGeometry(6, 1.5, blockSize), platMat);
                        platform2.position.set(px + 7, 13.5, 50); scene.add(platform2); walkableObjects.push(platform2);
                        
                        // é§…ã®å±‹æ ¹ (åŠé€æ˜ã‚¢ãƒ¼ãƒ)
                        //const roofMat = new THREE.MeshPhysicalMaterial({color: 0xaaccff, transparent: true, opacity: 0.3, side: THREE.DoubleSide, roughness: 0.1});
                        //const roof = new THREE.Mesh(new THREE.CylinderGeometry(13, 13, blockSize, 16, 1, true, 0, Math.PI));
                        //roof.rotation.z = Math.PI / 2; roof.rotation.x = Math.PI / 2;
                       //roof.position.set(px, 20, 50); scene.add(roof);
                    }
                    
                    // é“è·¯ã¯æç”»ã™ã‚‹
                    const roadX = new THREE.Mesh(new THREE.PlaneGeometry(blockSize, roadWidth), roadMat);
                    roadX.rotation.x = -Math.PI / 2; roadX.position.set(px, 0.05, pz - blockSize/2 + roadWidth/2);
                    scene.add(roadX); walkableObjects.push(roadX);
                    continue; // é€šå¸¸ã®ãƒ“ãƒ«ã¯å»ºã¦ãªã„
                }

                if (z === 0) {

    const isStation = (x === 0);

    // æ”¯æŸ±
    const pillar = new THREE.Mesh(
        new THREE.CylinderGeometry(1.5, 1.5, 12),
        concreteMat
    );
    pillar.position.set(px, 6, pz);
    scene.add(pillar);

    // ãƒ‡ãƒƒã‚­ï¼ˆå‘ããŒé•ã†ï¼ï¼‰
    const deckWidth = isStation ? 26 : 10;
    const deck = new THREE.Mesh(
        new THREE.BoxGeometry(blockSize + 1, 1, deckWidth),
        concreteMat
    );
    deck.position.set(px, 12.5, pz);
    scene.add(deck);
    walkableObjects.push(deck);

    // ãƒ¬ãƒ¼ãƒ«ï¼ˆå‘ããŒé•ã†ï¼‰
    const railMat = new THREE.MeshStandardMaterial({color:0x333333});

    const rail1 = new THREE.Mesh(
        new THREE.BoxGeometry(blockSize + 1, 0.5, 0.3),
        railMat
    );
    rail1.position.set(px, 13, pz - 2);
    scene.add(rail1);

    const rail2 = new THREE.Mesh(
        new THREE.BoxGeometry(blockSize + 1, 0.5, 0.3),
        railMat
    );
    rail2.position.set(px, 13, pz + 2);
    scene.add(rail2);

    continue;
}

                // --- é€šå¸¸ã®é“è·¯ ---
                const roadX = new THREE.Mesh(new THREE.PlaneGeometry(blockSize, roadWidth), roadMat);
                roadX.rotation.x = -Math.PI / 2; roadX.position.set(px, 0.05, pz - blockSize/2 + roadWidth/2);
                scene.add(roadX); walkableObjects.push(roadX);
                
                const roadZ = new THREE.Mesh(new THREE.PlaneGeometry(blockSize, roadWidth), roadMat);
                roadZ.rotation.x = -Math.PI / 2; roadZ.rotation.z = Math.PI / 2; roadZ.position.set(px - blockSize/2 + roadWidth/2, 0.05, pz);
                scene.add(roadZ); walkableObjects.push(roadZ);

                if (Math.random() > 0.3) {
                    const group = new THREE.Group(); group.position.set(px, 0, pz - blockSize/2 + roadWidth);
                    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 6, 8), new THREE.MeshStandardMaterial({color: 0x444}));
                    pole.position.y = 3; group.add(pole);
                    const bulbMat = new THREE.MeshBasicMaterial({color: 0xffddaa});
                    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), bulbMat);
                    bulb.position.y = 6; group.add(bulb);
                    scene.add(group);
                    streetLightPositions.push(new THREE.Vector3(px, 6, pz - blockSize/2 + roadWidth));
                    lightBulbs.push(bulbMat);
                }

                const bldSize = blockSize - roadWidth - 2;
                const group = new THREE.Group(); group.position.set(px + roadWidth/2, 0, pz + roadWidth/2);

                let h = 20 + Math.random() * 40;
                let mats = bldMaterials[Math.floor(Math.random() * bldMaterials.length)];

                // --- ç‰¹æ®Šå»ºç‰©ã®åˆ¤å®š ---
                const isTwinTowerLeft = (x === -1 && z === -1);
                const isTwinTowerRight = (x === 1 && z === -1);
                const isBank = (x === -1 && z === 0);
                const isMuseum = (x === 1 && z === 0);

                if (isTwinTowerLeft || isTwinTowerRight) {
                    // ãƒ„ã‚¤ãƒ³ã‚¿ãƒ¯ãƒ¼
                    h = 240; 
                    mats = bldMaterials[3]; // ã‚¬ãƒ©ã‚¹
                    
                    // ã‚¿ãƒ¯ãƒ¼ã‚’ä¸­å¤®(x=0)ã«å¯„ã›ã‚‹
                    if (isTwinTowerLeft) group.position.x += 8;
                    if (isTwinTowerRight) group.position.x -= 8;

                    const b = new THREE.Mesh(new THREE.BoxGeometry(bldSize, h, bldSize), mats);
                    b.position.y = h/2; b.castShadow = true; b.receiveShadow = true;
                    group.add(b); walkableObjects.push(b);

                    // æ¸¡ã‚Šå»Šä¸‹ (å·¦å´ã®ã‚¿ãƒ¯ãƒ¼ã‹ã‚‰å³ã«å‘ã‘ã¦ç”Ÿæˆ)
                    if (isTwinTowerLeft) {
                        const corridor = new THREE.Mesh(new THREE.BoxGeometry(40, 8, 8), bldMaterials[3][0]);
                        corridor.position.set(25, 150, 0); // ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã§å³ã«ä¼¸ã°ã™
                        group.add(corridor); walkableObjects.push(corridor);
                    }
                    addRoofDetails(group, h, bldSize);

                } else if (isBank) {
                    // éŠ€è¡Œ
                    h = 25;
                    const stoneMat = new THREE.MeshStandardMaterial({color: 0x7a7a6a, roughness: 0.9});
                    const bankMesh = new THREE.Mesh(new THREE.BoxGeometry(bldSize, h, bldSize), stoneMat);
                    bankMesh.position.y = h/2; group.add(bankMesh); walkableObjects.push(bankMesh);
                    
                    // æŸ±ã®è£…é£¾
                    for(let px_bank = -bldSize/2 + 2; px_bank <= bldSize/2 - 2; px_bank += 4) {
                        const p = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, h), stoneMat);
                        p.position.set(px_bank, h/2, bldSize/2 + 0.2); group.add(p);
                    }
                    
                    const sign = new THREE.Mesh(new THREE.PlaneGeometry(10, 3), new THREE.MeshBasicMaterial({color: 0xffaa00}));
                    sign.position.set(0, h - 3, bldSize/2 + 0.9); group.add(sign);
                    addRoofDetails(group, h, bldSize);

                } else if (isMuseum) {
                    // å›½ç«‹åšç‰©é¤¨
                    h = 20;
                    const musMat = new THREE.MeshStandardMaterial({color: 0xddddcc, roughness: 1.0});
                    
                    // åŸºå£‡
                    const base = new THREE.Mesh(new THREE.BoxGeometry(bldSize + 4, 2, bldSize + 4), musMat);
                    base.position.y = 1; group.add(base); walkableObjects.push(base);
                    
                    // å†…å£
                    const wall = new THREE.Mesh(new THREE.BoxGeometry(bldSize - 6, 12, bldSize - 6), musMat);
                    wall.position.y = 8; group.add(wall); walkableObjects.push(wall);
                    
                    // å‘¨å›²ã®æŸ±
                    for(let px_m = -bldSize/2; px_m <= bldSize/2; px_m += 4) {
                        for(let pz_m = -bldSize/2; pz_m <= bldSize/2; pz_m += bldSize) {
                            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 12), musMat);
                            p.position.set(px_m, 8, pz_m); group.add(p);
                        }
                    }
                    
                    // ä¸‰è§’å±‹æ ¹
                    const roof = new THREE.Mesh(new THREE.ConeGeometry(bldSize * 0.75, 8, 4), musMat);
                    roof.rotation.y = Math.PI / 4;
                    roof.position.y = 18; group.add(roof); walkableObjects.push(roof);

                } else {
                    // é€šå¸¸ã®ãƒ“ãƒ«
                    const b = new THREE.Mesh(new THREE.BoxGeometry(bldSize, h, bldSize), mats);
                    b.position.y = h/2; b.castShadow = true; b.receiveShadow = true;
                    group.add(b); walkableObjects.push(b);
                    addRoofDetails(group, h, bldSize);

                    // å±‹ä¸Šãƒ˜ãƒªãƒãƒ¼ãƒˆ (ä¸€éƒ¨ã®ãƒ“ãƒ«)
                    if (h >= 40 && Math.random() < 0.2) {
                        const heliport = new THREE.Mesh(new THREE.CylinderGeometry(bldSize/3, bldSize/3, 0.5, 16), new THREE.MeshStandardMaterial({color: 0x444444}));
                        heliport.position.set(0, h + 0.25, 0); group.add(heliport); walkableObjects.push(heliport);
                        const hMark = new THREE.Mesh(new THREE.PlaneGeometry(bldSize/4, bldSize/4), new THREE.MeshBasicMaterial({color: 0xffff00}));
                        hMark.rotation.x = -Math.PI/2; hMark.position.set(0, h + 0.51, 0); group.add(hMark);
                    }
                }
                scene.add(group);
            }
        }

        // --- 4ä¸¡ç·¨æˆã®é›»è»Š ---
        const trainGroup = new THREE.Group();
        const trainCarGeo = new THREE.BoxGeometry(4.5, 4.5, 15);
        const trainCarMat = new THREE.MeshStandardMaterial({color: 0xdddddd, metalness: 0.8, roughness: 0.2});
        const windowMat = new THREE.MeshBasicMaterial({color: 0x111111});
        const stripeMat = new THREE.MeshBasicMaterial({color: 0x0088ff}); // é’ã„ãƒ©ã‚¤ãƒ³

        for(let i=0; i<4; i++) {
            const car = new THREE.Group();
            const body = new THREE.Mesh(trainCarGeo, trainCarMat);
            body.position.y = 2.25; car.add(body);
            
            const win = new THREE.Mesh(new THREE.BoxGeometry(4.6, 1.5, 14), windowMat);
            win.position.y = 2.8; car.add(win);
            
            const stripe = new THREE.Mesh(new THREE.BoxGeometry(4.7, 0.4, 15.1), stripeMat);
            stripe.position.y = 1.6; car.add(stripe);

            car.position.z = i * -16; // 16é–“éš”ã§é€£çµ
            trainGroup.add(car);
        }
        trainGroup.position.set(0, 13.5, 200); // åˆæœŸä½ç½®
        scene.add(trainGroup);
        walkableObjects.push(trainGroup);

        // é›»è»Šã®çŠ¶æ…‹ç®¡ç†
        let trainDirection = 'north'; 
// north, south, east, west
        let trainState = 'running';
        let trainWaitTimer = 0;
        const trainSpeed = 30;

        
        function updateTrain(delta) {

    if (trainState === 'running') {

        // ç§»å‹•
        switch(trainDirection) {
            case 'north':
                trainGroup.position.z -= trainSpeed * delta;
                trainGroup.rotation.y = 0;
                break;

            case 'south':
                trainGroup.position.z += trainSpeed * delta;
                trainGroup.rotation.y = 0;
                break;

            case 'east':
                trainGroup.position.x += trainSpeed * delta;
                trainGroup.rotation.y = Math.PI / 2;
                break;

            case 'west':
                trainGroup.position.x -= trainSpeed * delta;
                trainGroup.rotation.y = Math.PI / 2;
                break;
        }

        // ã‚¯ãƒ­ã‚¹åœ°ç‚¹åˆ¤å®š
        if (Math.abs(trainGroup.position.x) < 5 &&
            Math.abs(trainGroup.position.z) < 5) {

            const dirs = ['north','south','east','west'];
            trainDirection = dirs[Math.floor(Math.random()*4)];
        }

        // ç«¯ã§åè»¢
        const limit = citySize / 2 + 100;

        if (trainGroup.position.z > limit) trainDirection = 'north';
        if (trainGroup.position.z < -limit) trainDirection = 'south';
        if (trainGroup.position.x > limit) trainDirection = 'west';
        if (trainGroup.position.x < -limit) trainDirection = 'east';
    }

    if (trainState === 'waiting') {
        trainWaitTimer -= delta;
        if (trainWaitTimer <= 0) trainState = 'running';
    }
}

        // --- ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚° ---
        const timeStops = [
            { t: 0.0, sky: 0x050510, sun: 0x222244, ambient: 0.1 },
            { t: 0.2, sky: 0x0a0a20, sun: 0x444466, ambient: 0.2 },
            { t: 0.25, sky: 0xffaa55, sun: 0xff8844, ambient: 0.4 },
            { t: 0.3, sky: 0x87ceeb, sun: 0xffeedd, ambient: 0.6 },
            { t: 0.7, sky: 0x87ceeb, sun: 0xffeedd, ambient: 0.6 },
            { t: 0.75, sky: 0xff6622, sun: 0xff4400, ambient: 0.4 },
            { t: 0.8, sky: 0x111133, sun: 0x333355, ambient: 0.2 },
            { t: 1.0, sky: 0x050510, sun: 0x222244, ambient: 0.1 }
        ];

        const maxLights = 8; 
        const lightPool = [];
        for(let i=0; i<maxLights; i++) {
            const sl = new THREE.SpotLight(0xffddaa, 0, 40, Math.PI/3, 0.5, 1);
            scene.add(sl); scene.add(sl.target); lightPool.push(sl);
        }

        // --- ãƒ˜ãƒªã‚³ãƒ—ã‚¿ãƒ¼ã‚·ã‚¹ãƒ†ãƒ  ---
        let heliInstance = null;
        let isDrivingHeli = false;
        let isHovering = false;
        let heliVelocity = new THREE.Vector3();
        let heliThrottle = 0;
        let heliPitch = 0, heliRoll = 0, heliYaw = 0;
        let rotorSpeed = 0;
        let headYaw = 0, headPitch = 0;

        function createHeli() {
            const group = new THREE.Group();
            
            // ãƒœãƒ‡ã‚£ (ã‚«ãƒ—ã‚»ãƒ«çŠ¶ã«å¼•ãä¼¸ã°ã—ãŸçƒä½“)
            const cabinGeo = new THREE.SphereGeometry(1.5, 32, 16);
            cabinGeo.scale(1, 0.8, 1.8);
            const cabinMat = new THREE.MeshStandardMaterial({color: 0x223344, roughness: 0.4, metalness: 0.6});
            const cabin = new THREE.Mesh(cabinGeo, cabinMat);
            cabin.position.set(0, 1.2, 0);
            group.add(cabin);

            // ã‚³ãƒƒã‚¯ãƒ”ãƒƒãƒˆã‚¬ãƒ©ã‚¹ (ã‚­ãƒ£ãƒ“ãƒ³ã®å‰åŠåˆ†ã«è¢«ã›ã‚‹)
            const glassGeo = new THREE.SphereGeometry(1.52, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2.2);
            glassGeo.rotateX(-Math.PI / 2); // å‰ã‚’å‘ã‘ã‚‹
            glassGeo.scale(1, 0.8, 1.8);
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0x111111, transparent: true, opacity: 0.7, roughness: 0.1, metalness: 0.9, side: THREE.DoubleSide
            });
            const glass = new THREE.Mesh(glassGeo, glassMat);
            glass.position.set(0, 1.2, 0);
            group.add(glass);

            // 3D HUD (å†…å´)
            const hudCanvas = document.createElement('canvas');
            hudCanvas.width = 1024; hudCanvas.height = 1024;
            const hudCtx = hudCanvas.getContext('2d');
            const hudTex = new THREE.CanvasTexture(hudCanvas);
            const hudMat = new THREE.MeshBasicMaterial({ 
                map: hudTex, transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false 
            });
            const hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), hudMat);
            hudMesh.position.set(0, 1.2, -1.8); // ã‚«ãƒ¡ãƒ©ã®å‰ã«é…ç½®
            group.add(hudMesh);
            
            group.userData.hudCtx = hudCtx;
            group.userData.hudTex = hudTex;

            const rotorMat = new THREE.MeshStandardMaterial({color: 0x888888, metalness: 0.5});
            
            // ãƒ¡ã‚¤ãƒ³ãƒ­ãƒ¼ã‚¿ãƒ¼æ”¯æŸ±
            const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.8), rotorMat);
            mast.position.set(0, 2.5, 0); group.add(mast);

            // ãƒ¡ã‚¤ãƒ³ãƒ­ãƒ¼ã‚¿ãƒ¼
            const rotorGroup = new THREE.Group();
            const mRotor1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.05, 14), rotorMat);
            const mRotor2 = new THREE.Mesh(new THREE.BoxGeometry(14, 0.05, 0.2), rotorMat);
            rotorGroup.add(mRotor1, mRotor2);
            rotorGroup.position.set(0, 2.9, 0);
            group.add(rotorGroup);
            group.userData.mainRotor = rotorGroup;

            // ãƒ†ãƒ¼ãƒ«ãƒ–ãƒ¼ãƒ  (å¾Œã‚ã«ä¼¸ã³ã‚‹æ”¯æŸ±)
            const boomGeo = new THREE.CylinderGeometry(0.25, 0.1, 4.5);
            boomGeo.rotateX(Math.PI / 2);
            const boom = new THREE.Mesh(boomGeo, cabinMat);
            boom.position.set(0, 1.3, 3.5);
            group.add(boom);

            // å‚ç›´å°¾ç¿¼ (å®‰å®šæ¿)
            const finGeo = new THREE.BoxGeometry(0.1, 1.8, 1.0);
            const fin = new THREE.Mesh(finGeo, cabinMat);
            fin.position.set(0, 1.6, 5.5);
            group.add(fin);

            // ãƒ†ãƒ¼ãƒ«ãƒ­ãƒ¼ã‚¿ãƒ¼
            const tailRotorGroup = new THREE.Group();
            const tRotorGeo = new THREE.BoxGeometry(0.05, 2.0, 0.15);
            const tRotor = new THREE.Mesh(tRotorGeo, rotorMat);
            tailRotorGroup.add(tRotor);
            tailRotorGroup.position.set(0.15, 1.6, 5.5);
            group.add(tailRotorGroup);
            group.userData.tailRotor = tailRotorGroup;

            // ã‚¹ã‚­ãƒƒãƒ‰(è„š)
            const skidGeo = new THREE.CylinderGeometry(0.1, 0.1, 5); skidGeo.rotateX(Math.PI/2);
            const skid1 = new THREE.Mesh(skidGeo, rotorMat); skid1.position.set(-1.2, -0.2, 0.5);
            const skid2 = new THREE.Mesh(skidGeo, rotorMat); skid2.position.set(1.2, -0.2, 0.5);
            group.add(skid1, skid2);
            
            const supGeo = new THREE.CylinderGeometry(0.05, 0.05, 1);
            [[-1.2,-0.5], [1.2,-0.5], [-1.2,1.5], [1.2,1.5]].forEach(([x,z]) => {
                const sup = new THREE.Mesh(supGeo, rotorMat); sup.position.set(x, 0.3, z); group.add(sup);
            });

            return group;
        }

        function updateEnvironment(time) {
            // èˆªç©ºéšœå®³ç¯ã®ç‚¹æ»… (0.75ç§’ã”ã¨)
            const avOn = (time % 1.5) < 0.75;
            aviationLights.forEach(mat => mat.color.setHex(avOn ? 0xff0000 : 0x220000));

            let t = fixedTime >= 0 ? fixedTime : ((time * 0.02) + 0.22) % 1.0;

            const angle = t * Math.PI * 2;
            const sunY = -Math.cos(angle); const sunX = Math.sin(angle);
            sunLight.position.set(sunX * 400, sunY * 400, 100);

            let currentSky = new THREE.Color(), currentSun = new THREE.Color(), currentAmbient = 0;
            for (let i = 0; i < timeStops.length - 1; i++) {
                if (t >= timeStops[i].t && t <= timeStops[i+1].t) {
                    const progress = (t - timeStops[i].t) / (timeStops[i+1].t - timeStops[i].t);
                    currentSky.copy(new THREE.Color(timeStops[i].sky)).lerp(new THREE.Color(timeStops[i+1].sky), progress);
                    currentSun.copy(new THREE.Color(timeStops[i].sun)).lerp(new THREE.Color(timeStops[i+1].sun), progress);
                    currentAmbient = timeStops[i].ambient + (timeStops[i+1].ambient - timeStops[i].ambient) * progress;
                    break;
                }
            }

            scene.background = currentSky; scene.fog.color.copy(currentSky);
            sunLight.color.copy(currentSun); sunLight.intensity = Math.max(0, sunY) * 1.5;
            ambientLight.intensity = currentAmbient;

            let starOpacity = 0;
            if (t < 0.22) starOpacity = 1.0 - (t / 0.22);
            else if (t > 0.78) starOpacity = (t - 0.78) / 0.22;
            starField.material.opacity = Math.min(1.0, starOpacity * 1.5);

            const isDark = (t < 0.28 || t > 0.72); 
            bldEmissiveMats.forEach(mat => mat.emissiveIntensity = isDark ? 1.5 : 0.4);
            lightBulbs.forEach(mat => mat.color.setHex(isDark ? 0xffddaa : 0x444444));

            if (!isDark) { lightPool.forEach(l => l.intensity = 0); } 
            else {
                const distances = streetLightPositions.map(pos => ({ dist: camera.position.distanceToSquared(pos), pos: pos }))
                                                      .sort((a, b) => a.dist - b.dist);
                for(let i=0; i<maxLights; i++) {
                    const sl = lightPool[i];
                    if (i < distances.length && distances[i].dist < 5000) {
                        sl.position.copy(distances[i].pos); 
                        sl.target.position.set(distances[i].pos.x, 0, distances[i].pos.z);
                        sl.intensity = 6;
                    } else { sl.intensity = 0; }
                }
            }
        }

        // --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œã¨ã‚¢ã‚¤ãƒ†ãƒ ã‚·ã‚¹ãƒ†ãƒ  ---
        let pitch = 0, yaw = 0;
        let velocity = new THREE.Vector3(); 
        const gravity = -40, jumpForce = 18, climbSpeed = 12;
        const keys = { w: false, a: false, s: false, d: false, q: false, e: false, shift: false, space: false };
        let keyH_pressed = false; 
        
        blocker.addEventListener('click', () => {
            settingsPanel.style.display = 'none'; document.body.requestPointerLock();
        });
        document.addEventListener('pointerlockchange', () => {
            blocker.style.display = document.pointerLockElement === document.body ? 'none' : 'flex';
            if (document.pointerLockElement !== document.body) for(let k in keys) keys[k] = false;
        });

        document.addEventListener('keydown', e => {
            const k = e.key.toLowerCase();
            if (k === ' ') keys.space = true; else if (keys.hasOwnProperty(k)) keys[k] = true;

            if (k === 'h' && !keyH_pressed) {
                if (isDrivingHeli) isHovering = !isHovering;
                keyH_pressed = true;
            }

            if (k === 'f' && document.pointerLockElement === document.body) {
                if (isDrivingHeli) {
                    isDrivingHeli = false; isHovering = false;
                    document.getElementById('heli-panel').style.display = 'none';
                    const exitOffset = new THREE.Vector3(3, 0.5, 0).applyQuaternion(heliInstance.quaternion);
                    camera.position.copy(heliInstance.position).add(exitOffset);
                    yaw = heliYaw + headYaw; pitch = headPitch; 
                    velocity.set(0,0,0);
                } else if (heliInstance && heliInstance.position.distanceTo(camera.position) < 8) {
                    isDrivingHeli = true; document.getElementById('heli-panel').style.display = 'block';
                    velocity.set(0,0,0); headYaw = 0; headPitch = 0;
                    heliYaw = new THREE.Euler().setFromQuaternion(heliInstance.quaternion, 'YXZ').y;
                }
            }
        });
        document.addEventListener('keyup', e => {
            const k = e.key.toLowerCase();
            if (k === ' ') keys.space = false; else if (keys.hasOwnProperty(k)) keys[k] = false;
            if (k === 'h') keyH_pressed = false;
        });

        document.addEventListener('mousemove', e => {
            if (document.pointerLockElement === document.body) {
                if (isDrivingHeli) {
                    headYaw -= e.movementX * 0.002; headPitch -= e.movementY * 0.002;
                    headPitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, headPitch));
                    headYaw = Math.max(-Math.PI/1.2, Math.min(Math.PI/1.2, headYaw)); 
                } else {
                    yaw -= e.movementX * 0.002; pitch -= e.movementY * 0.002;
                    pitch = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, pitch));
                    camera.quaternion.copy(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), yaw))
                                     .multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), pitch));
                }
            }
        });

        let hookTarget = null;
        const laserMat = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 3 });
        const laserGeo = new THREE.BufferGeometry();
        laserGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
        const laserLine = new THREE.Line(laserGeo, laserMat);
        scene.add(laserLine); laserLine.visible = false;

        document.addEventListener('mousedown', e => {
            if (document.pointerLockElement !== document.body || e.button !== 0) return;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const hits = raycaster.intersectObjects(walkableObjects, true);

            if (currentItem === 'heli') {
                if (!heliInstance) { heliInstance = createHeli(); scene.add(heliInstance); }
                
                let spawnDist = 8;
                const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                forward.y = 0; forward.normalize();
                
                const spawnPos = camera.position.clone().add(forward.multiplyScalar(spawnDist));
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼(ã‚«ãƒ¡ãƒ©)ã®Yåº§æ¨™ã‚’åŸºæº–ã«ä¸‹æ–¹å‘ã¸ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆ
                spawnPos.y = camera.position.y;
                const downHits = new THREE.Raycaster(spawnPos, new THREE.Vector3(0,-1,0)).intersectObjects(walkableObjects);
                
                if (downHits.length > 0) {
                    spawnPos.y = downHits[0].point.y + 0.5; // ãƒ’ãƒƒãƒˆã—ãŸåœ°é¢/å±‹æ ¹ã®ä¸Š
                } else {
                    spawnPos.y = Math.max(camera.position.y, 2); // è½ä¸‹é˜²æ­¢
                }
                
                heliInstance.position.copy(spawnPos);
                heliVelocity.set(0,0,0); heliPitch = 0; heliRoll = 0;
                
                const playerEuler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                heliYaw = playerEuler.y + Math.PI; 
                heliInstance.quaternion.setFromAxisAngle(new THREE.Vector3(0,1,0), heliYaw);
            }
            else if (currentItem === 'laser' && hits.length > 0) {
                hookTarget = hits[0].point; laserLine.visible = true;
            } 
            else if (currentItem === 'gun' && hits.length > 0) {
                const obj = hits[0].object;
                if (obj.geometry.type !== 'PlaneGeometry' && obj.geometry.type !== 'BoxGeometry') {
                    const targetGroup = obj.parent && obj.parent.type === 'Group' ? obj.parent : obj;
                    scene.remove(targetGroup);
                    if (targetGroup.type === 'Group') {
                        targetGroup.children.forEach(c => {
                            const idx = walkableObjects.indexOf(c); if (idx > -1) walkableObjects.splice(idx, 1);
                        });
                    } else {
                        const idx = walkableObjects.indexOf(targetGroup); if (idx > -1) walkableObjects.splice(idx, 1);
                    }
                }
            }
        });

        document.addEventListener('mouseup', e => {
            if (e.button !== 0) return;
            if (currentItem === 'laser' && hookTarget) {
                const dir = new THREE.Vector3().subVectors(hookTarget, camera.position).normalize();
                velocity.copy(dir.multiplyScalar(70)); 
                hookTarget = null; laserLine.visible = false;
            }
        });

        function updatePlayer(delta) {
            const speed = keys.shift ? 45 : 15;
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); forward.y = 0; forward.normalize();
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion); right.y = 0; right.normalize();

            const dir = new THREE.Vector3();
            if (keys.w) dir.z -= 1; if (keys.s) dir.z += 1;
            if (keys.a) dir.x -= 1; if (keys.d) dir.x += 1;
            dir.normalize();

            const move = new THREE.Vector3().addScaledVector(forward, -dir.z).addScaledVector(right, dir.x).multiplyScalar(speed * delta);

            camera.position.add(velocity.clone().multiplyScalar(delta));
            velocity.x -= velocity.x * 3 * delta; velocity.z -= velocity.z * 3 * delta;

            let currentGravity = gravity;
            let isClimbing = false;

            if (keys.w) {
                const hits = new THREE.Raycaster(camera.position, forward, 0, 1.5).intersectObjects(walkableObjects);
                if (hits.length > 0) { isClimbing = true; velocity.y = climbSpeed; move.set(0,0,0); }
            }

            if (currentItem === 'glider') {
                const downHits = new THREE.Raycaster(camera.position, new THREE.Vector3(0, -1, 0)).intersectObjects(walkableObjects);
                const floorDist = downHits.length > 0 ? camera.position.y - downHits[0].point.y : 100;
                if (keys.shift && velocity.y <= 0 && floorDist > 3) {
                    currentGravity = -3; camera.position.add(forward.multiplyScalar(35 * delta));
                }
            }

            if (!isClimbing) velocity.y += currentGravity * delta;
            camera.position.y += velocity.y * delta;
            camera.position.add(move);

            const downHits = new THREE.Raycaster(camera.position, new THREE.Vector3(0, -1, 0)).intersectObjects(walkableObjects);
            if (downHits.length > 0) {
                const floorY = downHits[0].point.y;
                if (velocity.y <= 0 && camera.position.y - 2.0 <= floorY + 0.2) {
                    camera.position.y = floorY + 2.0; velocity.y = 0;
                    if (keys.space) velocity.y = jumpForce;
                }
            } else if (camera.position.y < -5) { camera.position.y = 2; velocity.set(0,0,0); }

            if (currentItem === 'laser' && hookTarget) {
                const pos = laserLine.geometry.attributes.position.array;
                const r = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                const d = new THREE.Vector3(0, -1, 0).applyQuaternion(camera.quaternion);
                const start = camera.position.clone().add(r.multiplyScalar(0.5)).add(d.multiplyScalar(0.5));
                pos[0] = start.x; pos[1] = start.y; pos[2] = start.z;
                pos[3] = hookTarget.x; pos[4] = hookTarget.y; pos[5] = hookTarget.z;
                laserLine.geometry.attributes.position.needsUpdate = true;
            } else { laserLine.visible = false; }
        }

        function updateHeliSystem(delta, time) {
            if (!heliInstance) return;

            rotorSpeed = THREE.MathUtils.lerp(rotorSpeed, heliThrottle * 40, delta * 2);
            if (!isDrivingHeli) heliThrottle = THREE.MathUtils.lerp(heliThrottle, 0, delta * 0.5);
            
            heliInstance.userData.mainRotor.rotation.y -= rotorSpeed * delta;
            heliInstance.userData.tailRotor.rotation.x -= rotorSpeed * delta * 1.5;

            let targetPitch = 0, targetRoll = 0, targetYawRate = 0;

            if (isDrivingHeli) {
                if (isHovering) {
                    const hoverBaseThrottle = 1.0 / 2.1; 
                    const altCorrection = -heliVelocity.y * 0.05; 
                    const targetThrottle = hoverBaseThrottle + altCorrection;
                    heliThrottle = THREE.MathUtils.lerp(heliThrottle, Math.max(0, Math.min(1, targetThrottle)), delta * 2);

                    if (keys.space || keys.shift || keys.w || keys.s || keys.a || keys.d || keys.q || keys.e) isHovering = false;
                } else {
                    if (keys.space) heliThrottle = Math.min(1.0, heliThrottle + delta * 0.4);
                    if (keys.shift) heliThrottle = Math.max(0.0, heliThrottle - delta * 0.4);
                }

                if (keys.w) targetPitch = 0.3; if (keys.s) targetPitch = -0.3;
                if (keys.a) targetRoll = 0.3; if (keys.d) targetRoll = -0.3;
                if (keys.q) targetYawRate = 1.0; if (keys.e) targetYawRate = -1.0;
            }

            heliPitch = THREE.MathUtils.lerp(heliPitch, targetPitch, delta * 3);
            heliRoll = THREE.MathUtils.lerp(heliRoll, targetRoll, delta * 3);
            heliYaw += targetYawRate * delta * 1.5;

            const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), heliYaw);
            const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), heliPitch);
            const qRoll = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), heliRoll);
            heliInstance.quaternion.copy(qYaw).multiply(qPitch).multiply(qRoll);

            const upVector = new THREE.Vector3(0, 1, 0).applyQuaternion(heliInstance.quaternion);
            const heliGravity = 15; const maxThrust = heliGravity * 2.1; 
            const thrust = upVector.clone().multiplyScalar(heliThrottle * maxThrust);
            const gravityForce = new THREE.Vector3(0, -heliGravity, 0);

            const windForce = new THREE.Vector3(
                Math.sin(time * 1.5) * 2 + Math.cos(time * 2.3) * 1.5,
                Math.sin(time * 2.1) * 1,
                Math.cos(time * 1.7) * 2 + Math.sin(time * 2.9) * 1.5
            );
            const floatFactor = Math.min(1.0, heliInstance.position.y / 20) * (0.5 + heliThrottle * 0.5);
            windForce.multiplyScalar(floatFactor * 2.5);

            const totalForce = new THREE.Vector3().addVectors(thrust, gravityForce).add(windForce);
            heliVelocity.add(totalForce.multiplyScalar(delta));
            heliVelocity.multiplyScalar(0.98); 

            const downHits = new THREE.Raycaster(heliInstance.position, new THREE.Vector3(0, -1, 0)).intersectObjects(walkableObjects);
            let floorY = 0; if (downHits.length > 0) floorY = downHits[0].point.y;

            if (heliInstance.position.y <= floorY + 0.1 && heliVelocity.y < 0) {
                heliInstance.position.y = floorY + 0.1;
                heliVelocity.y = 0; heliVelocity.x *= 0.8; heliVelocity.z *= 0.8; 
                heliPitch = THREE.MathUtils.lerp(heliPitch, 0, delta * 5); 
                heliRoll = THREE.MathUtils.lerp(heliRoll, 0, delta * 5);
            }

            heliInstance.position.add(heliVelocity.clone().multiplyScalar(delta));

            if (isDrivingHeli) {
                const cockpitOffset = new THREE.Vector3(0, 1.2, -0.8).applyQuaternion(heliInstance.quaternion);
                camera.position.copy(heliInstance.position).add(cockpitOffset);

                const qHeadYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), headYaw);
                const qHeadPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), headPitch);
                camera.quaternion.copy(heliInstance.quaternion).multiply(qHeadYaw).multiply(qHeadPitch);
            }

            if (isDrivingHeli && heliInstance.userData.hudCtx) {
                const ctx = heliInstance.userData.hudCtx;
                ctx.clearRect(0, 0, 1024, 1024);
                
                ctx.fillStyle = '#00ffcc'; ctx.strokeStyle = '#00ffcc';
                ctx.font = 'bold 36px monospace'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                
                if (isHovering) {
                    ctx.fillStyle = '#ffaa00'; ctx.fillText(`[ HOVERING ]`, 60, 150); ctx.fillStyle = '#00ffcc';
                }
                ctx.fillText(`ALT: ${Math.max(0, Math.floor(heliInstance.position.y))} m`, 60, 200);
                
                const barX = 60, barY = 280, barW = 30, barH = 300;
                ctx.fillStyle = 'rgba(0, 255, 204, 0.2)'; ctx.fillRect(barX, barY, barW, barH);
                ctx.fillStyle = '#00ffcc';
                const fillH = heliThrottle * barH; ctx.fillRect(barX, barY + barH - fillH, barW, fillH);
                ctx.lineWidth = 2; ctx.strokeRect(barX, barY, barW, barH);
                const hoverLineY = barY + barH - (1.0 / 2.1) * barH;
                ctx.fillStyle = '#ff3333'; ctx.fillRect(barX - 10, hoverLineY - 2, barW + 20, 4);
                
                ctx.fillStyle = '#00ffcc';
                ctx.fillText(`THR`, 55, barY - 25);
                ctx.fillText(`${Math.floor(heliThrottle * 100)}%`, 110, barY + barH - fillH);

                const speedKmh = Math.floor(heliVelocity.length() * 3.6);
                ctx.fillText(`SPD: ${speedKmh} km/h`, 60, 620);

                ctx.save(); ctx.translate(512, 512); 
                ctx.rotate(heliRoll); ctx.translate(0, heliPitch * 800); 

                ctx.lineWidth = 4; ctx.beginPath();
                ctx.moveTo(-250, 0); ctx.lineTo(-80, 0); ctx.moveTo(80, 0); ctx.lineTo(250, 0);
                ctx.moveTo(-80, 0); ctx.lineTo(-80, 20); ctx.moveTo(80, 0); ctx.lineTo(80, 20);
                ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.stroke();

                ctx.font = '24px monospace'; ctx.textAlign = 'center';
                for(let i = -4; i <= 4; i++) {
                    if(i === 0) continue;
                    const y = i * 150; ctx.beginPath();
                    const w = (Math.abs(i) % 2 === 0) ? 60 : 30;
                    ctx.moveTo(-w, y); ctx.lineTo(w, y); ctx.stroke();
                    if(w === 60) {
                        ctx.fillText(Math.abs(i)*10, -w - 30, y); ctx.fillText(Math.abs(i)*10, w + 30, y);
                    }
                }
                ctx.restore();

                ctx.textAlign = 'right';
                const heading = ((-heliYaw * 180 / Math.PI) + 360) % 360;
                ctx.fillText(`HDG: ${Math.floor(heading)}Â°`, 964, 200);

                ctx.lineWidth = 2; ctx.strokeRect(40, 40, 944, 944);
                ctx.beginPath();
                ctx.moveTo(512, 40); ctx.lineTo(512, 80); ctx.moveTo(512, 984); ctx.lineTo(512, 944);
                ctx.moveTo(40, 512); ctx.lineTo(80, 512); ctx.moveTo(984, 512); ctx.lineTo(944, 512);
                ctx.stroke();

                heliInstance.userData.hudTex.needsUpdate = true;
            }
        }

        const clock = new THREE.Clock();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();
            
            if (document.pointerLockElement === document.body) {
                if (!isDrivingHeli) updatePlayer(delta);
            }
            updateTrain(delta);
            updateHeliSystem(delta, time);
            updateEnvironment(time);
            
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
